#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Пищик Е.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |      5        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Существует два подхода к решению логических задач:
1) Метод порождения и проверки
2) Метод ветвей и границ

Prolog оказывается удобным, потому что в первом методе генерируются все варианты решений, а потом они перебираются, как раз это и делает Prolog проходя все варианты в дереве и делая откат при неудаче. Во втором методе проверка условий происходит одновременно с генерацией решений, таким образом отсекаются целые ветви неподходящих решений, что как раз удобно реализуется в прологе его деревьями решений и механизмом отсечения.

## Задание

Дина, Соня, Коля, Рома и Миша учатся в институте. Их фамилии Бойченко, Карпенко, Лысенко, Савченко и Шевченко. Мать Ромы умерла. Родители Дины никогда не встречались с родителями Коли. Студенты Шевченко и Бойченко играют в одной баскетбольной команде. Услышав, что родители Карпенко собираются поехать за город, мать Шевченко пришла к матери Карпенко и попросила, чтобы та отпустила своего сына к ним на вечер, но оказалось, что отец Коли уже договорился с родителями Карпенко и пригласил их сына к Коле. Отец и мать Лысенко хорошие друзья родителей Бойченко. Все четверо очень довольны, что их дети собираются пожениться. Установите имя и фамилию каждого из молодых людей и девушек.

## Принцип решения

Для получения результата почти вся логика помещена в предикат `solve/1`, который в список RES записывает полученные пары вида "имя"="фамилия".
Пример использования:
```prolog
2 ?- solve(RES).
RES = ["Соня"="Бойченко", "Миша"="Карпенко", "Коля"="Лысенко", "Рома"="Савченко", "Дина"="Шевченко"] ;
false.
```
Теперь пройдемся по всему коду:
При помощи `name("имя")` мы сохраняем все имена наших героев.
```prolog
% Имена
name("Дина").
name("Соня").
name("Коля").
name("Рома").
name("Миша").
```

Аналогичным образом определяем пол при помощи `gender("имя", f/m)`.
```prolog
% Определяем пол каждой персоны
gender("Дина", f).
gender("Соня", f).
gender("Коля", m).
gender("Рома", m).
gender("Миша", m).
```

Напишем предикаты проверки на совпадение пола: `same_gender(X,Y)` и на различие пола: `diff_gender(X, Y)`.
```prolog
% Равенство гендеров
same_gender(X, Y) :- gender(X, Z), gender(Y, Z).
% Различный гендер
diff_gender(X, Y) :- not(same_gender(X, Y)).
```

Из условия определим предикат `without_mom("имя")`, который показывает отсутствие матери.
Также определим предикат `has_mom(X)` через отрицание для `without_mom(X)`.
```prolog
% Отсутствие мамы
without_mom("Рома").
% Наличие мамы
has_mom(X) :- not(without_mom(X)).
```

Аналогичным образом определяем следующие предикаты:
```prolog
% Родители Дины никогда не встречались с родителями Коли
parents_not_knows("Коля", "Дина").
parents_knows(X, Y) :- not(parents_not_knows(X, Y)), not(parents_not_knows(Y, X)).
% Отец Коли договорился с родителями Карпенко -> Коля != Карпенко
not_name("Коля", "Карпенко").
my_not(X, Y) :- not(not_name(X, Y)).
```

Теперь разберем сам предикат `solve(RES)`:
В начале мы в списке RES определяем переменные некоторыми атомами, потом переменные кладем в предикат `name(X)`, проверяем на различность имён при помощи `my_unique(X)`, все что написано дальше это правила взятые из условия задачи и положенные в заданные нами выше предикаты `has_mom(X)`, `parents_knows(X,Y)`, `gender(X, Y)`, `my_not(X,Y)`, `diff_gender(X,Y)`, `same_gender(X,Y)`.
```prolog
solve(RES) :-
	RES = [N1 = "Бойченко",	N2 = "Карпенко", N3 = "Лысенко", N4 ="Савченко", N5 = "Шевченко"],
	name(N1), name(N2),	name(N3), name(N4),	name(N5),
	% Проверка на уникальность имен
	my_unique([N1, N2, N3, N4, N5]),
	% Шевченко и Бойченко играют в одной баскетбольной команде -> одинковый пол
	same_gender(N5, N1),
	% Мать Шевченко пришла к матери Карпенко -> у Шевченко и Карпенко есть матери и они знакомы
	has_mom(N5),
	has_mom(N2),
	parents_knows(N5, N2),
	% Пол Карпенко - мужской
	gender(N2, m),
	% Имя Карпенко != Коля
	my_not(N2, "Карпенко"),
	% Но оказалось, что отец Коли уже договорился с родителями Карпенко -> они знакомы
	parents_knows(N2, "Коля"),
	% Отец и мать Лысенко хорошие друзья родителей Бойченко. Все четверо очень довольны,
	% что их дети собираются пожениться -> Лысенко и Бойченко разного пола
	diff_gender(N3, N1),
	% Отец и мать Лысенко хорошие друзья родителей Бойченко. Все четверо очень довольны,
	% что их дети собираются пожениться -> у Лысенко и Бойченко есть матери и их родители знакомы
	has_mom(N3),
	has_mom(N1),
	parents_knows(N1, N3).
```
Т.к. мы сами инициализируем список `RES` фамилиями мы избавляемся от перебора, что ускоряет работу примерно в 5! раз.
Когда мы переменные кладем в предикаты `name(X)` происходит генерация ответов, количество сгенерированных ответов = 5^5.
Также тут нет никаких зацикливаний, что обеспечивает целостность решения.

## Выводы

Prolog оказался достаточно удобным для решения различных логических загадок, т.к. можно интуитивно понятно задать предикаты для условий, сгенерировать все возможны решения и при помощи проверки заданных условий найти нужное решение, причем то, что человек будет сопоставлять в голове достаточно продолжительное время Prolog сделает значительно быстрее, что является очевидным преимуществом, ибо все что тут нужно - правильно записать данные нам условия в Prolog, а дальше он сделает всё сам. Также я познакомился с механизмом отсечения, который позволяет избавится от излишнего перебора или зацикливания, существует два вида отсечений - красные и зелёные. Красные отсечения - теряют часть решений, зелёные - не теряют решений, но ускоряют работу программы путём избежания лишнего перебора.




