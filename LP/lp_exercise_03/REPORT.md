#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Пищик Е.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Задачи, которые требует нахождения определенного пути, решаются при помощи поиска очень удобно, т.к. можно найти кратчайший путь или просто обойти в нужном порядке, в Prolog-е удобно реализовывать алгоритмы поиска, т.к. сам Prolog выбирает свои решения при помощи поиска в глубину -> он хорошо работает с bfs, dfs и т.п.

## Задание

Вариант 5.

Вдоль доски расположено 7 лунок, в которых лежат 3 черных и 3 белых шара.
Передвинуть черные шары на место белых, а белые - на место черных.
Шар можно передвинуть в соседнюю с ним пустую лунку, либо в пустую лунку, находящуюся непосредсвенно за ближайшим шаром.

## Принцип решения

Для решения нам понадобится 3 основных вещи - факты состояний задачи, предикат перехода между состояниями и какой-нибудь вид поиска(в ширину, в глубину, поиск с итерационным погружением). Далее мы просто задаем начальное и конечное состояния задачи и запускаем поиск, который делает перебор переходов и ищет нужный путь. 


Опишем предикат вставки элемента в список `append(L1,L2,L3`:
```prolog
append([], L, L).
append([H|T], L, [H|TRES]) :- append(T, L, TRES).
```


Опишем предикат состояний `move(A,B)`:
```prolog
move(A,B) :- append(H, ['_','w'|T], A), append(H, ['w','_'|T], B).
move(A,B) :- append(H, ['w','_'|T], A), append(H, ['_','w'|T], B).
move(A,B) :- append(H, ['_','b'|T], A), append(H, ['b','_'|T], B).
move(A,B) :- append(H, ['b','_'|T], A), append(H, ['_','b'|T], B).
move(A,B) :- append(H, ['_','b','w'|T], A), append(H, ['w','b','_'|T], B).
move(A,B) :- append(H, ['_','w','b'|T], A), append(H, ['b','w','_'|T], B).
move(A,B) :- append(H, ['b','w','_'|T], A), append(H, ['_','w','b'|T], B).
move(A,B) :- append(H, ['w','b','_'|T], A), append(H, ['_','b','w'|T], B).
```


Опишем предикат перехода между состояними `prolong(L1,L2)`:
```prolog
prolong([X|T], [Y,X|T]) :- move(X, Y), not(member(Y, [X|T])).
```


Опишем предикаты поиска в ширину, глубину и поиска с итерационным погружением `bfs(X,Y)`, `dfs(X,Y)`, `search_id(X,Y)`:
```prolog
% Поиск в ширину.
bfs(X, Y) :- write(X), bdth([[X]], Y, Z), print(Z), !.
bdth([[H|T]|_], H, [H|T]).
bdth([H|T], X, Z) :- findall(W, prolong(H, W), Y), append(T, Y, E), !, bdth(E, X, Z).
bdth([_,T], X, Y) :- bdth(T, X, Y).

% Поиск в глубину.
dfs(X, Y) :- write(X), ddth([[X]], Y, Z), print(Z), !.
ddth([[H|T]|_], H, [H|T]).
ddth([H|T], X, Z) :- findall(W, prolong(H, W), Y), append(Y, T, E), !, ddth(E, X, Z).
ddth([_,T], X, Y) :- ddth(T, X, Y).

% Поиск с итерационным погружением.
search_id(X, Y, W, D) :- depth_id([X], Y, W, D).
depth_id([H|T], H, [H|T], 0).
depth_id(W, X, Y, N) :- N>0, prolong(W, NEWW), N1 is N-1, depth_id(NEWW, X, Y, N1).
search_id(X, Y, W) :- int(LEV), search_id(X, Y, W, LEV).
search_id(X, Y) :- write(X), search_id(X, Y, Z), print(Z), !.
int(1).
int(N) :- int(N1), N is N1+1.
```

## Результаты

```prolog
2 ?- search_id(['b','b','b','_','w','w','w'],['w','w','w','_','b','b','b']). 
[b,b,b,_,w,w,w]
[b,b,b,w,_,w,w]
[b,b,_,w,b,w,w]
[b,_,b,w,b,w,w]
[b,w,b,_,b,w,w]
[b,w,b,w,b,_,w]
[b,w,b,w,b,w,_]
[b,w,b,w,_,w,b]
[b,w,_,w,b,w,b]
[_,w,b,w,b,w,b]
[w,_,b,w,b,w,b]
[w,w,b,_,b,w,b]
[w,w,b,w,b,_,b]
[w,w,b,w,_,b,b]
[w,w,_,w,b,b,b]
[w,w,w,_,b,b,b]
true.

3 ?- bfs(['b','b','b','_','w','w','w'],['w','w','w','_','b','b','b']).       
[b,b,b,_,w,w,w]
[b,b,b,w,_,w,w]
[b,b,_,w,b,w,w]
[b,_,b,w,b,w,w]
[b,w,b,_,b,w,w]
[b,w,b,w,b,_,w]
[b,w,b,w,b,w,_]
[b,w,b,w,_,w,b]
[b,w,_,w,b,w,b]
[_,w,b,w,b,w,b]
[w,_,b,w,b,w,b]
[w,w,b,_,b,w,b]
[w,w,b,w,b,_,b]
[w,w,b,w,_,b,b]
[w,w,_,w,b,b,b]
[w,w,w,_,b,b,b]
true.

4 ?- dfs(['b','b','b','_','w','w','w'],['w','w','w','_','b','b','b']). 
[b,b,b,_,w,w,w]
[b,b,b,w,_,w,w]
[b,b,_,w,b,w,w]
[b,b,w,_,b,w,w]
[b,b,w,b,_,w,w]
[b,b,w,b,w,_,w]
[b,b,w,_,w,b,w]
[b,b,w,w,_,b,w]
[b,b,w,w,b,_,w]
[b,b,w,w,b,w,_]
[b,b,w,w,_,w,b]
[b,b,w,_,w,w,b]
[b,b,_,w,w,w,b]
[b,_,b,w,w,w,b]
[b,w,b,_,w,w,b]
[b,w,b,w,_,w,b]
[b,w,b,w,w,_,b]
[b,w,b,w,w,b,_]
[b,w,b,w,_,b,w]
[b,w,b,_,w,b,w]
[b,w,_,b,w,b,w]
[b,_,w,b,w,b,w]
[_,b,w,b,w,b,w]
[w,b,_,b,w,b,w]
[w,b,b,_,w,b,w]
[w,b,b,w,_,b,w]
[w,b,b,w,b,_,w]
[w,b,b,w,b,w,_]
[w,b,b,w,_,w,b]
[w,b,b,_,w,w,b]
[w,b,_,b,w,w,b]
[w,_,b,b,w,w,b]
[_,w,b,b,w,w,b]
[b,w,_,b,w,w,b]
[b,w,w,b,_,w,b]
[b,w,w,b,w,_,b]
[b,w,w,b,w,b,_]
[b,w,w,b,_,b,w]
[b,w,w,_,b,b,w]
[b,w,_,w,b,b,w]
[b,_,w,w,b,b,w]
[_,b,w,w,b,b,w]
[w,b,_,w,b,b,w]
[w,b,w,_,b,b,w]
[w,b,w,b,_,b,w]
[w,b,w,b,b,_,w]
[w,b,w,b,b,w,_]
[w,b,w,b,_,w,b]
[w,b,w,b,w,_,b]
[w,b,w,_,w,b,b]
[w,b,w,w,_,b,b]
[w,b,w,w,b,_,b]
[w,b,w,_,b,w,b]
[w,b,_,w,b,w,b]
[w,_,b,w,b,w,b]
[_,w,b,w,b,w,b]
[b,w,_,w,b,w,b]
[b,w,w,_,b,w,b]
[b,w,w,w,b,_,b]
[b,w,w,w,_,b,b]
[b,w,w,_,w,b,b]
[b,w,_,w,w,b,b]
[b,_,w,w,w,b,b]
[_,b,w,w,w,b,b]
[w,b,_,w,w,b,b]
[w,_,b,w,w,b,b]
[w,w,b,_,w,b,b]
[w,w,b,w,_,b,b]
[w,w,_,w,b,b,b]
[w,w,w,_,b,b,b]
true.
```
ID, bfs - длина первого найденого пути намного меньше чем в dfs, время работы у dfs может быть хуже, т.к. поиск уйдет не в самый короткий путь.

|-Алгоритм-поиска-|-Длина-найденного-первым-пути|

|----В-глубину----|--------------70-------------|

|-----В-ширину----|--------------16-------------|

|-------ID--------|--------------16-------------|

## Выводы

Я научился реализовывать различные алгоритмы поиска на Prolog-е: dfs, bfs, ID, также я выделили для себя плюсы и минусы каждого поиска и задачи для которых их лучше использовать, научился решать задачи поиска пути при помощи алгоритмов поиска, также научился оценивать сложность и затраты памяти алгоритмов в Prolog-е. 
Для нахождения кратчайшего пути первым нужно использовать bfs, если очень важна память, то нужно использовать dfs. Нужно помнить, что dfs может пойти не в самый короткий путь и в программах с большим количеством путей и переходов время работы может значительно увеличиться. Так как сам пролог находит свои решения алгоритмом поиска в глубину, то этот вариант является простейшим в реализации, если первый найденный путь равен первому найденному пути при помощи другого алгоритма поиска, то время работы dfs будет меньше чем у других алгоритмов поиска.  
