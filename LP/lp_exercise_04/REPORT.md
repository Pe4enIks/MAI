#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Пищик Е.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |     5-        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*
Выписать грамматику (с правилами перехода) в явном виде.

## Введение

Существует 2 основных способа анализа языков:

+ Лексический анализ.
+ Синтаксический анализ.
  + Контекстно-свободный синтаксический анализ.
  + Контекстно-зависимый синтаксический анализ.

В Prolog есть встроенный механизм для разбора/анализа языка, что и является основным удобством использования Prolog.

## Задание
Вариант 10.

Реализовать разбор фраз языка, представляющих собой положительные и отрицательные высказывания. В результате предикат должен выдавать все атомарные глубинные структуры.

## Принцип решения

Задаем факты `name(X)` и `subjects(X)`.
```prolog
name("Женя").
name("Андрей").
name("Олег").

subjects("бананы").
subjects("орехи").
subjects("яблоки").
```

Задаем предикат `opposition(X,Y)`, который при помощи предиката `append(X,Y,Z)`, сохраняет в `Y` фразу после противопоставления, `X` - полная фраза.
```prolog
opposition(X, Y) :- append(_, ["но"|Y], X).
opposition(X, Y) :- append(Y, ["но"|_], X).
opposition(X, Y) :- append(_, ["а"|Y], X).
opposition(X, Y) :- append(Y, ["а"|_], X).
```

Задаем предикаты `like(X,Y)` и `not_like(X,Y)`, которые аналогично предикату `opposition(X,Y)` сохраняеют в `Y` фразу после слов любит/не любит, где `X` - полная фраза.
```prolog
like(X, Y) :- append(_, ["любит"|Y], X).
not_like(X, Y) :- append(_, ["не", "любит"|Y], X).
```

Задаем предикат `subject(X, Y, Z)`, который будет нам сохранять в `Y` имя субъекта с которым мы работаем.
```prolog
subject([H|_], H, _) :- subjects(H), write(H).
subject([_|T], X, Y) :- subject(T, X, Y).
```

Задаем предикаты `like_name(X, Y, Z)` и `not_like(X,Y,Z)` - два предиката которые создают предикаты `likes(X,Y`) и `not_likes(X,Y)`.
```prolog
like_name(X, likes(Y, Z), Y) :- subject(X, Z, Y).
not_like_name(X, not_likes(Y, Z), Y) :- subject(X, Z, Y).
```

Задаем предикаты `my_phrase(X, Y, Z)` и `opposition_phrase(X, Y, Z)`, которые как раз разбирают нашу фразу `Y` для имени `X` и сохраняют в `Z` полученные предикаты.
```prolog
my_phrase(X, Y, Z) :- not(not_like(Y,K)), like(Y, K), like_name(K, Z, X).
my_phrase(X, Y, Z) :- not_like(Y, K), not_like_name(K, Z, X).
opposition_phrase(X, Y, Z) :- opposition(Y, K), my_phrase(X, K, Z).
```

Задаем финальный предикат `decompose([H|T], X)`, где мы ищем при помощи предиката `name(X)` имя соответствующее `H`, и делаем разбор фразы `T` - хвоста нашего списка, тоесть фразы без имени, сохраняем полученные в результате разбора предикаты в `X`.
```prolog
decompose([H|T], X) :- name(H), opposition_phrase(H, T, X).
decompose([H|T], X) :- name(H), not(opposition_phrase(H, T, X)), my_phrase(H, T, X).
```

## Результаты

```prolog
9 ?- decompose(["Женя", "не","любит", "орехи", "но", "любит", "яблоки", "и", "бананы"], RES).
RES = likes("Женя", "яблоки") ;
RES = likes("Женя", "бананы") ;
RES = not_likes("Женя", "орехи") ;
false.
```

```prolog
2 ?- decompose(["Олег", "любит", "бананы"], RES).                    
RES = likes("Олег", "бананы") ;
false.
```

```prolog
3 ?- decompose(["Андрей", "любит", "бананы", "и", "яблоки", "но", "не", "любит", "орехи"], RES).  
RES = not_likes("Андрей", "орехи") ;
RES = likes("Андрей", "бананы") ;
RES = likes("Андрей", "яблоки") ;
false.
```

```prolog
4 ?- decompose(["Андрей", "любит", "бананы", "и", "яблоки", "а", "не", "любит", "орехи"], RES).  
RES = not_likes("Андрей", "орехи") ;
RES = likes("Андрей", "бананы") ;
RES = likes("Андрей", "яблоки") ;
false.
```

## Выводы

Prolog позволяет достаточно удобно решать задачу разбора/анализа языка, однако мне кажется в данный момент данные задачи намного более хорошо решаются при помощи нейросетей. Однако не все мы имеем возможность использовать какие-то хорошие модели из NLP, здесь Prolog казывается достаточно удобным, в нем есть встроенный механизм для разбора/анализа предложений, можно самому ограничить задачу некоторым словарем, можно делать разбор/анализ предложений не учитывая некоторые слова, например предлоги, союзы и т.п., просто не занося их в словарь. К тому же полученные после разбора предикаты можно удобно использовать для решения более конкретной задачи в Prolog, тем самым позволяя пользователю в качестве запроса подавать некоторые общие фразы и получать ожидаемый результат.




