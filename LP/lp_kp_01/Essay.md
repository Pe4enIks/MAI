# Реферат
## по курсу "Логическое программирование"

### студент: Пищик Е.С.

## Типовые и бестиповые логические языки: обзор и сравнение.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

### Краткий обзор языка Prolog
Prolog - язык и система логического программирования, основанные на языке предикатов математической логики дизъюнктов Хорна, представляющей собой подмножество логики предикатов первого порядка. Будучи декларативным языком программирования, Prolog воспринимает в качестве программы некоторое описание задачи и сам производит логический вывод, а также поиск решения задач, пользуясь механизмом поиска с возвратом и унификацией. В Prolog существует всего один тип term. программа на языке Prolog состоит из набора правил и фактов. Факты - какие-то известные нам утверждения, правила - зависимости использующие факты. В процессе поиска строится дерево решений, происходит его обход с унификацией переменных и процессов бэктрекинга. Язык Prolog - бестиповой, что несет в себе как минусы, так и плюсы.

Пример простой программы на Prolog:
```prolog
child(jenya, natalia).
child(alex, natalia).
child(jenya, sergei).
child(alex, sergei).
male(alex).
male(jenya).
male(sergei).
female(natalia).

mother(X, Y) :- child(Y, X), female(X).
father(X, Y) :- child(Y, X), male(X).
son(X, Y) :- child(X, Y), male(X).
daughter(X, Y) :- child(X, Y), female(X).
```
В данной программе `male`, `female` и `child` - факты, а `mother` и `father` правила, причем когда мы пишем код, мы пишем отношения прям как в жизни, логически понятно, хотим указать пол - пишем term: `male/femal`e и т.п. По итогу мы получаем программу которая может определять отношение `mother/father/son/daughter`, причем можно просто спросить является ли `jenya` сыном `natalia` и получить `true` или указать переменную вместо одно из имен и Prolog попробует найти имя подходящее под данное правило.

### Краткий обзор языка Mercury
Mercury — язык функционально-логического программирования со строгой типизацией, призванный решить следующие две проблемы, которые возникают при использовании классического языка логического программирования Prolog:
1. Проблема производительности. Т.к. тип не известен заранее, время работы сильно увеличивалось, т.к. требовались дополнительные проверки на перебор типов и проверки совместимости.
2. Проблема отладки. В Prolog искать ошибки, связанные с типизацией было сложно, здесь это попробовали исправить.

Программа на языке Mercury включает в себя следующие элементы:
1.	:−module – заголовок модуля.
2.	:−interface – интерфейсная часть, здесь описано то, что должно быть доступно другим модулям. Чтобы программа была исполняемой, хотя бы один модуль должен экспортировать управляющий предикат main(который должен выполнятся без возвратов).
3.	:−import_module – импорт из других модулей.
4.	:-type – пользовательские типы данных.
5.	:−pred – определение предиката, в нем указываются типы аргументов, его режимы варианты детерминизма.
6.	Каждая программа в Mercury должна иметь определение предиката main, с которого начинает работу программа.
7.	:−implementation – реализационная часть модуля, содержит реализации всех необходимых предикатов.


Пример простой программы на Mercury:
```prolog
 :- module fib.
 :- interface.
 :- import_module io.
 :- pred main(io::di, io::uo) is det.
 
 :- implementation.
 :- import_module int.

 :-func fib(int) = int.
 fib(N) = (if N =< 2 then 1 else fib(N - 1) + fib(N - 2)).

 main(!IO) :-
        io.write_string("fib(10) = ", !IO),
        io.write_int(fib(10), !IO),
        io.nl(!IO).
```

Как можно заметить в строке `func fib(int) = int.` мы как раз указываем типы данных. Языки логического и функционального программирования изначально были бестиповыми, чтобы следовать структуре базовой математической теории(логики предикатов и лямбда-исчисления соответственно). Но в mercury решили уйти от этого.

### Поиск решения в Prolog и Mercury.
Каким образом работает поиск с бэктрегингом? Это достаточно хорошо можно пояснить, вот на каком примере.
Предположим, для достижения некоторой цели человеку необходимо последовательно принять несколько решений и выполнить некоторые действия в соответствии с принятыми решениями. Первоначально человек без колебаний и раздумий принимает несколько решений, но при решении очередной проблемы у него возникают сомнения, поскольку возможных решений, предположим, имеется два, и человеку они кажутся одинаково правильными. Какое-либо из двух решений человек все равно принимает и продолжает свое движение к поставленной цели.
Но, в какой-то момент оказывается, что решение, выбранное из двух, все же оказалось неправильным. Тогда человек вернется в точку принятия неверного решения, и пойдет по альтернативному пути. Не факт, что вновь выбранный путь окажется правильным, но человек попробует все возможные варианты нахождения решения.
В данном случае выбор решения - унификация переменных, возврат в точку принятия неверного решения - бэктрекинг.

### Что такое тип данных
У понятия типа есть несколько определений:
1. Множество допустимых значений, которые могут принимать данные, принадлежащие к этому типу.
2. Набор операций, которые можно осуществлять над данными, принадлежащими к этому типу.
3. Набор заданных размерных и структурных характеристик ячейки памяти, в которую можно поместить некое значение, соответствующее этим характеристикам.

В каждом языке есть набор базовых типов, например: int, double, char и т.д.(C++). Они могут иметь разные названия и различный диапазон значений, являтся целочисленными, действительными, стрококвыми. 

Типы делятся на:
1. Знаковые - значения в диапазоне [-inf, +inf], например int, long, long long(C++).
2. Беззнаковые - значения в диапазоне [0, +inf], например unsigned int, size_t(C++).

### Типизация
Понятие типизации появилось в первую очередь в связи с появлением понятия переменной в языках программирования. Как мы помним, переменная в императивных языках программирования - непрерывный промежуток памяти, выделенный программе для использования и имеющий уникальное имя. Так как работать с сырым куском памяти не очень удобно, во многих языках для переменных был определен набор типов, которые могут характеризовать переменные. Типизация - как язык распознает и понимает типы данных.

Типизация бывает:
1. Статическая - C++, C, Pascal, Haskell, Jave, Mercury.
2. Динамическая - Python, JavaScript, Lisp, Prolog.

Языки со статической типизацией проверяют типы в программе во время компиляции, еще до запуска программы. Любая программа, в которой типы нарушают правила языка, считается некорректной и вызывает исключение. 

Языки с динамической типизацией ничего не знают о типах данных до запуска программы, информация о типе становится доступна только после инициализации данных.

Например в C++ данный код будет выдавать ошибку при компиляции:
```cpp
int func(int num, std::string str)
{
  return num+str;
}
```
А в Python такой код не будет выдавать ошибку пока вы не вызовете данную функцию с несовместимыми типами, напрмер int и string:
```python
def func(num, str):
  return num+str;
```

Статическая типизация позволяет значительно упростить поиск ошибок. Также, благодаря типизации можно создавать более производительный и понятный код, так как принимая некоторые аргументы, во многих случаях приходится проверять их содержимое. Такие проверки могут стать ненужными при появлении в языке типизации. Однако динамическая ситуация упрощает написание кода, т.к. программисту не нужно задумываться об указании типа.

### Плюсы и минусы динамической типизации
Плюсы:
1. Позволяет писать на предельно низком уровне, причем компилятор/интерпретатор не будет заниматься лишней проверкой. Вы вольны производить любые операции над любыми видами данных.
2. Простота чтения кода. Всегда понятно, что делает тот или иной код.

Минусы:
1. Сложность создания небазовых типов.
2. Скорость работы.
3. Любые бессмысленные действия допустими, что приводит к сложности обработки ошибок.

### Плюсы и минусы статической типизации
Плюсы:
1. Нельзя написать код производящий взаимодействие несовместимых типов.
2. Проверка происходит до запуска, ошибки становится отлавливать проще.
3. Невозможно пропустить ошибку, в динмаческой типизации пока ты не вызовешь некорректное взаимодействие ошибки не будет, здесь же если ты написал некорректное взаимодействие сразу будет ошибка.
4. Легко создавать небазовые типы.

Минусы:
1. Дополнительные затраты на указание типов.
2. Сложнее читать код.

### Типовые и бестиповые логические языки
Для примера возьмем два логических языка: swi-prolog и mercury. Swi-prolog является бестиповым языком, т.е. при программировании программист не указывает типы данных, ошибка типизации может возникнуть только во время выполнения. Чаще всего ошибка возникает при неправильном взаимодействии предикатов. Mercury является языком типовым языком, т.е. в нем программист производит описание типов для данных и в случае, если программист пишет код, где происходит взаимодействие несовместимых типов, то будет выдана ошибка. 

Существует несколько категорий ошибок, которые могут появиться в логических программах. В частности к ним относятся ошибки, связанные с неправильным взаимодействием предикатов друг с другом. Причиной таких ошибок может стать неправильное упорядочивание аргументов, несоответствие реального содержимого переданного аргумента с ожидаемым и прочие ошибки, которые вызваны в основном тем, что язык предоставляет только один тип данных - универсальный.

Проверка типов в языках логического программирования полезна по многим причинам. Она позволяет писать гораздо более читабельные и простые для понимания программы. Также, декларирование и проверка типов обеспечивают уверенность в том, что код программы написан правильно и она будет работать именно так, как задумывалось.

### Типы в swi-prolog
Swi-prolog имеет всего один тип данных term, которому и относятся все возможные сущности, определенные в языке. Термы делятся на простые и структурные. Простые термы включают в себя константы и переменные. Константы, в свою очередь, могут быть представлены числами или атомами.

Term-ы разделяется на:
1. Переменная. Не унифицируется ни с одним конкретным термином. Переменные идентифицируются символами, соответствующими регулярному выражению [A-Z_][A-Za-z_0-9]. Переменная _ является особенной - это анонимная переменная. Каждое вхождение в _ обозначает отдельную переменную. Однако, как только переменная унифицируется, она перестает быть переменной: если это не отменить путем бэктрекинга, она навсегда унифицированной данным значением.
2. Число - это либо float, либо integer. Применяются обычные правила: например -231: integer, 32.0: float.
3. Атом - это имена, обычно обозначаемые словом, начинающимся со строчной буквы (например, atom), что соответствует регулярному выражению [a-z][A-Za-z0-9_]. В качестве альтернативы атомы могут быть разделены апострофами (например, 'Евгений Пищик'), которые удобно позволяют использовать символы, не допускаемые в противном случае. Все что не попадает в переменную или число - атом.
4. Составной терм - атом, состоящий из функтора и списка аргументов.
5. Список - определяется рекурсивно, как некоторый головной элемент, и хвост(также являющийся списком). [H|T] - список с H-головой и T-списком хвостом. Пустой список обозначается как [].
6. Строка - последовательность символов, заключенных в кавычки. 

В языках логического программирования под переменной подразумевается совсем другая сущность, нежели в императивных языках. Здесь все переменные являются просто ссылками, указывающими на некоторую произвольную структуру. Операция явного присваивания значения тоже отсутствует. За заполнение переменных некоторыми значениями отвечает механизм, называемый унификацией. Унификация позволяет сопоставлять значения переменным в процессе вызова предикатов, что в комбинации с бэктрекингом дает широчайшие возможности для перебора вариантов, а это является одним из основных преимуществ логических языков.

### Типы в mercury
Mercury логический язык со строгой типизацией, тем самым мы можем с уверенностью сказать, что если программа на mercury запустилась, то ошибок, связанных с типизацией, не будет. Таким образом происходит значиельная оптимизация работы программы, ибо все типы известные заранее.

Данные типы являются встроенными или определенными в библиотеке mercury:
1. Примитивные типы: char, int, float, string. Существует специальный синтаксис для констант типа int, float, and string, для char используется обычный синтаксис.
2. Предикаты: pred, pred(X).
3. Функции: (f) = X, f(X) = Y.
4. Кортежи: {}, {X}, {X, Y}.
5. Универсальный тип 'univ'
6. Prolog: term.

### Системы типов.
Типом в логическом языке программирования является набор некоторых структурных термов. В этих термах позиция аргумента связана с тем, какого наполнения ожидает программист от этого терма. Типы в логическах язык вводятся для различимости значимого и не имеющего смысла. Соответственно, в программах на swi-prolog не нужно как-либо декларировать типы, так как типы объектов распознаются по их синтаксическому представлению в программе, например, если слово начинается с маленькой буквы - это атом, если с большой - переменная.
В mercury несколько все сложнее, сначала нужно определить набор типов, также нужно определить, что такое конфликт типов и какие взаимодействия могут быть с тем или иным типом данных. Корректность системы типов - свойство формальной системы вывода типов, которое формулируется следующим образом: если выражение типизированно корректно и из него с помощью правил вывода можно получить другое выражения, то оно тоже корректно типизированное. Коротко говоря, это свойство сохранения правильности типов при выводе. Из корректности системы типов следует, что типизация будет корректной на всем протяжении выполнении программы, если она была корректна до компиляции.

### Вывод
Prolog - логический бестиповой язык программирования, ошибки типизации здесь возникают только во время работы программы и отлпаливать их крайне сложно, программа на Prlog-е состоит из набора фактов и правил, запрос на языке Prlog представляет собой процесс постороения, обхода дерева с унификацией переменных, отсечением и бэктрекингом, Mercury использует похожую схему для запросов, правил, фактов, однако ялвляется типовым логическим языком, тем самым ошибки типизации будут известны по ходу написания, отладка намного проще, скорость работы также увеличивается за счет сокращения времени, которое выделялось на поиск подходящих типов, которые не конфликтуют. На логических языках программирования, как Prolog, Mercury удобно решать логические задачи, описывать математические предикаты первой степени, воообще написание программ очень похоже на ход мыслей человека, что как раз упрощает написание кода, как думаешь, так и пиши.

### Литература
1. [Тип данных](https://ru.wikipedia.org/wiki/Тип_данных)
2. [Типизация](https://habr.com/ru/post/308484/)
3. [Prolog](https://ru.wikipedia.org/wiki/Пролог_(язык_программирования))
4. [Mercury](https://ru.bmstu.wiki/Mercury_(язык_программирования))
